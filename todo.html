<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="container"></div>

    <script>
        const TASK_CREATED = 'TASK_CREATED'

        const initialStore = {
            tasks: []
        };

        // Task Component

        const Task = (task) =>
            createElement('div', [
                createElement('h4', [task.title])
            ]);

        // TaskList Component

        const TaskList = (tasks) =>
            createElement('div', tasks.map(Task));

        // NewTask Component

        const NewTask = (dispatch) => (newTask) =>
            createElement('form', [
                createElement('input', [newTask.title], { type: 'text', name: 'title' }),
                createElement('button', ['Create'])
            ], { onsubmit: dispatchFormData(dispatch, TASK_CREATED) });

        // Todo Component

        const Todo = (dispatch) => (store) =>
            createElement('div', [
                NewTask((a, p) => dispatch(a, p, store))(store.newTask || {}),
                TaskList(store.tasks)
            ]);

        // Todo Actions Handler

        TodoActions = (dispatch) => (action, payload, store) => {
            switch (action) {
                case TASK_CREATED:
                    dispatch({ tasks: [payload, ...store.tasks] });
                    break;
            }
        };

        // Todo App

        const TodoApp = (renderer) => Todo(TodoActions(renderer));

        // Entrypoint

        const main = (store) => {
            const tasksList = TodoApp(main)(store);
            render(tasksList); // <-- side-effect
        }

        main(initialStore);

        // ------------------------------------------------------------------
        // helper methods
        // ------------------------------------------------------------------

        function dispatchFormData(dispatch, ...args) {
            return (e) => {
                dispatch.apply(this, args.concat(extractFormData(e.target.elements)));
                e.preventDefault();
            }
        }

        function extractFormData(elements) {
            return Array.from(elements)
                .filter(e => !!e.name)
                .map(e => ({ [e.name]: e.value }))
                .reduce((ac, e) => ({ ...ac, ...e }));
        }

        function render(content) {
            const container = document.getElementById('container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            container.append(content);
        }

        function createElement(tagName, children, options) {
            const el = document.createElement(tagName);
            for (const prop in options) {
                if (!options.hasOwnProperty(prop)) continue;
                if (prop.toLowerCase().startsWith('on')) {
                    el.addEventListener(prop.substr(2), options[prop]);
                } else {
                    el.setAttribute(prop, options[prop]);
                }
            }
            children.forEach(c => {
                if (typeof c === 'string') el.append(c);
                else el.append(c);
            });
            return el;
        }
    </script>
</body>

</html>